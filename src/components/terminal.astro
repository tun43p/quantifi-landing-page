---
interface Props {
  contents: TerminalContent[];
}

const { contents } = Astro.props;
---

<div class="terminal">
  {
    Astro.slots.has("default") && (
      <aside class="terminal-aside">
        <slot />
      </aside>
    )
  }
  <section class="terminal-section">
    {
      contents.map((content: TerminalContent, index: number) => (
        <div class="terminal-line">
          <p
            class="terminal-text"
            aria-index={index}
            aria-value={content.text}
            aria-symbol={content.symbol}
          />
        </div>
      ))
    }
  </section>
</div>

<style>
  .terminal-aside {
    height: 18rem;
    margin-bottom: 2rem;
    /* TODO: Display none? */
    visibility: hidden;
  }

  .terminal-line {
    display: flex;
    align-items: center;
  }
</style>

<script>
  (() => {
    const texts = document.querySelectorAll("p.terminal-text");

    if (!texts) return;

    texts.forEach((text) => {
      const index = parseInt(text.getAttribute("aria-index") ?? "0");

      const value = text.getAttribute("aria-value");
      const symbol = text.getAttribute("aria-symbol");

      if (!value) return;

      let i = 0;

      let seed = 0;
      let speed = 50;

      // Function to type the text content of the terminal with a random speed
      const type = () => {
        if (i < value.length) {
          text.textContent += value.charAt(i);
          i++;

          seed = Math.floor(Math.random() * 10);
          speed = Math.floor(Math.random() * 10 * seed) + 50;

          if (seed === 5) speed = 250;

          setTimeout(type, speed);
        }
      };

      // If the text is the first one, type it immediately
      if (index === 0) {
        type();
        return;
      }

      // If the text is not the first one, wait for the previous text to finish typing
      const i1 = setInterval(() => {
        const previousText = texts[index - 1];
        const previousValue = previousText?.getAttribute("aria-value");

        if (previousValue == null || previousText?.textContent == null) {
          return;
        }

        if (previousText.textContent.length === previousValue.length) {
          type();
          clearInterval(i1);
          return;
        }
      }, speed);

      // If the text has a symbol, add it to the text content
      if (symbol) {
        const symbolText = document.createElement("span");
        text.parentElement?.appendChild(symbolText);

        const i2 = setInterval(() => {
          if (text.textContent?.length === value.length) {
            setInterval(() => {
              if (symbol === ".") {
                if (symbolText.textContent === "...") {
                  symbolText.textContent = ".";
                } else {
                  symbolText.textContent += ".";
                }
              } else if (symbol === "/") {
                symbolText.style.marginLeft = "0.5rem";

                if (symbolText.textContent === "/") {
                  symbolText.textContent = "|";
                } else if (symbolText.textContent === "|") {
                  symbolText.textContent = "\\";
                } else {
                  symbolText.textContent = "/";
                }
              }
            }, 500);

            clearInterval(i2);
          }
        });
      }
    });

    // If all the text contents have been typed, stop the typing animation
    const i3 = setInterval(() => {
      const lastText = texts[texts.length - 1];
      const lastValue = lastText?.getAttribute("aria-value");

      if (lastValue == null || lastText?.textContent == null) {
        return;
      }

      if (lastText.textContent.length === lastValue.length) {
        document
          .querySelector(".terminal-aside")
          ?.setAttribute("style", "visibility: visible");

        clearInterval(i3);

        return;
      }
    }, 500);
  })();
</script>
